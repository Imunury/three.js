<!DOCTYPE html>
<html>
    <head>
        <title>3D Water Simulation</title>
        <style>
        body { margin: 0; }
        canvas { display: block; }
        #heightInput { position: absolute; top: 1rem; left: 1rem; z-index: 100; }
        #waterVolume { position: absolute; top: 1rem; left: 13rem; z-index: 1000; color: white; margin: 0;}
    </style>
    </head>
    <body>
        <input id="heightInput" type="number" placeholder="Enter height...">
        <h3 id="waterVolume">10000</h3>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.144.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.144.0/examples/jsm/",
                    "three/addons/controls/": "https://unpkg.com/three@0.144.0/examples/jsm/controls/"
                }
            }
            </script>
        <script type="module">
            import * as THREE from 'https://unpkg.com/three/build/three.module.js';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

            const renderer = new THREE.WebGLRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); document.body.appendChild( renderer.domElement );
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 1000  ); 
            const controls = new OrbitControls( camera, renderer.domElement ); 
            //controls.update()는 카메라 변환설정을 수동으로 변경한 후에 호출해야 합니다. camera.position.set( 0, 20, 100 ); controls.update(); function animate() { requestAnimationFrame( animate ); // 만약 controls.enableDamping, controls.autoRotate 둘 중 하나라도 true로 설정될 경우 필수로 호출되어야 합니다. controls.update(); renderer.render( scene, camera ); }
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            camera.position.set(-20, 20, -20);
            camera.lookAt(new THREE.Vector3(0, 0, 0));
            
            // 물의 표면 생성
            const waterTexture = new THREE.TextureLoader().load('../public/water-7395510_1920.jpg'); // 실제 텍스처 경로로 변경
            waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
            const waterMaterial = new THREE.MeshBasicMaterial({ map: waterTexture, side: THREE.DoubleSide });
            const waterGeometry = new THREE.PlaneGeometry(20, 30, 64, 64);
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            //ater.position.y += 5; // 물의 표면을 y축 방향으로 2단위만큼 올림

            scene.add(water);

            // 사이드 벽 생성
            const sideMaterial = new THREE.MeshBasicMaterial({ map: waterTexture });
            const sideGeometry = new THREE.BoxGeometry(20, 1, 30);
            const side = new THREE.Mesh(sideGeometry, sideMaterial);
            scene.add(side);
            
            // 산의 지형 생성 함수
        function createMountainGeometry(width, height, depth, segments, detail) {
            const mountainGeometry = new THREE.PlaneGeometry(width, depth, segments, segments);
            
            // SimplexNoise를 이용하여 굴곡 생성
            const simplex = new SimplexNoise();
            for (let i = 0; i < mountainGeometry.vertices.length; i++) {
                const vertex = mountainGeometry.vertices[i];
                const noise = simplex.noise3D(vertex.x / detail, vertex.y / detail, vertex.z / detail);
                vertex.z += noise * height;
            }
            
            mountainGeometry.computeFaceNormals();
            mountainGeometry.computeVertexNormals();
            
            return mountainGeometry;
        }
            
            // 산의 지형 생성
            const leftMountainGeometry = new THREE.BoxGeometry(20, 10, 30); // 육면체 모양의 산
            const leftMountainMaterial = new THREE.MeshBasicMaterial({ color: 0x996633 });
            const leftMountain = new THREE.Mesh(leftMountainGeometry, leftMountainMaterial);
            leftMountain.position.set(20, 5, 0); // 산의 위치를 물 아래로 이동
            scene.add(leftMountain);

            const rightMountainGeometry = new THREE.BoxGeometry(40, 10, 30); // 육면체 모양의 산
            const rightMountainMaterial = new THREE.MeshBasicMaterial({ color: 0x996633 });
            const rightMountain = new THREE.Mesh(rightMountainGeometry, rightMountainMaterial);
            rightMountain.position.set(10, 5, 30); // 산의 위치를 물 아래로 이동
            scene.add(rightMountain);


            
            // 물이 흐르는 효과
            function animate() {
                requestAnimationFrame(animate);

                const time = performance.now() * 0.001;
                const positions = waterGeometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // X와 Y 좌표에 따라 높이 변화를 줌으로써 물결 효과 생성
                    const x = positions[i];
                    const y = positions[i + 1];
                    positions[i + 2] = Math.sin(x * 2 + time) * Math.cos(y * 2 + time) * 0.5;
                }

                waterGeometry.attributes.position.needsUpdate = true;

                // 물과 사이드 벽의 텍스처 오프셋을 애니메이션으로 조정
                const offsetSpeed = 0.001; // 텍스처 이동 속도
                waterTexture.offset.y -= offsetSpeed;
                // sideMaterial.map.offset.y -= offsetSpeed; // 사이드 벽 텍스처도 함께 이동

                renderer.render(scene, camera);
            }
            
            animate();

            document.getElementById('heightInput').addEventListener('change', function(e) {
                const height = parseFloat(e.target.value);
                // Update the side and water position based on the input value
                side.position.y = height / 2; // Adjust based on the center of the geometry
                water.position.y = height; // Set water position to the input value
                side.scale.y = height; // Scale side to match the input height
                document.getElementById('waterVolume').textContent = height * 10000
            });
            
    </script>
    </body>
</html>
