<!DOCTYPE html>
<html>
    <head>
        <title>3D Water Simulation</title>
        <style>
        body { margin: 0; }
        canvas { display: block; }
        #heightInput { position: absolute; top: 1rem; left: 1rem; z-index: 100; }
        .h3 { position: absolute; top: 1rem; left: 13rem; z-index: 1000; color: white; margin: 0;}
    </style>
    </head>
    <body>
        <input id="heightInput" type="number" placeholder="Enter height...">
        <h3 id="waterVolume" class="h3">10000</h3>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.0.0/simplex-noise.min.js"></script>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.144.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.144.0/examples/jsm/",
                    "three/addons/controls/": "https://unpkg.com/three@0.144.0/examples/jsm/controls/"
                }
            }
            </script>

        <script type="module">
            import * as THREE from 'https://unpkg.com/three/build/three.module.js';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            import { SimplexNoise } from 'https://unpkg.com/three@0.144.0/examples/jsm/math/SimplexNoise.js';


            const renderer = new THREE.WebGLRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); document.body.appendChild( renderer.domElement );
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 1000  ); 
            const controls = new OrbitControls( camera, renderer.domElement ); 
            //controls.update()는 카메라 변환설정을 수동으로 변경한 후에 호출해야 합니다. camera.position.set( 0, 20, 100 ); controls.update(); function animate() { requestAnimationFrame( animate ); // 만약 controls.enableDamping, controls.autoRotate 둘 중 하나라도 true로 설정될 경우 필수로 호출되어야 합니다. controls.update(); renderer.render( scene, camera ); }
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            camera.position.set(-20, 20, -20);
            camera.lookAt(new THREE.Vector3(0, 0, 0));
            
            // 물의 표면 생성
            const waterTexture = new THREE.TextureLoader().load('../public/water-7395510_1920.jpg'); // 실제 텍스처 경로로 변경
            waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
            const waterMaterial = new THREE.MeshBasicMaterial({ map: waterTexture, side: THREE.DoubleSide });
            const waterGeometry = new THREE.PlaneGeometry(20, 30, 64, 64);
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            //ater.position.y += 5; // 물의 표면을 y축 방향으로 2단위만큼 올림

            scene.add(water);

            // 사이드 벽 생성
            const sideMaterial = new THREE.MeshBasicMaterial({ map: waterTexture });
            const sideGeometry = new THREE.BoxGeometry(20, 1, 30);
            const side = new THREE.Mesh(sideGeometry, sideMaterial);
            scene.add(side);
            
            // SimplexNoise 초기화
            const simplex = new SimplexNoise();

            // 산의 지형 생성 함수
        // 산의 지형 생성 함수
function createNoiseGeometry(width, height, depth, segments, detail) {
    const noiseGeometry = new THREE.PlaneGeometry(width, depth, segments, segments);

    // 각 꼭지점에 대해 랜덤한 높이를 생성합니다.
    const positions = noiseGeometry.attributes.position.array;
    const middleIndex = Math.floor(segments / 5);
    
    for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const noise = simplex.noise(x / detail, y / detail);
        const randomHeight = Math.random() * height; // 랜덤한 높이 생성
        
        // 굴곡을 생성합니다.
        positions[i + 2] = noise * randomHeight;
        
        // 중간 부분은 평평하게 유지합니다.
        if (Math.abs(x) < width / 2 && y === 0) {
            positions[i + 2] = 0;
        }
    }

    // 버텍스 법선을 계산합니다.
    noiseGeometry.computeVertexNormals(); 
    
    return noiseGeometry;
}


            // 왼쪽 산의 지형 생성
            const leftNoiseGeometry = createNoiseGeometry(20, 10, 30, 64, 10);
            const leftNoiseMaterial = new THREE.MeshBasicMaterial({ color: 0x996633 });
            const leftNoise = new THREE.Mesh(leftNoiseGeometry, leftNoiseMaterial);
            leftNoise.position.set(20, 5, 0); // 산의 위치를 물 아래로 이동
            scene.add(leftNoise);

            // 오른쪽 산의 지형 생성
            const rightNoiseGeometry = createNoiseGeometry(40, 10, 30, 64, 10);
            const rightNoiseMaterial = new THREE.MeshBasicMaterial({ color: 0x996633 });
            const rightNoise = new THREE.Mesh(rightNoiseGeometry, rightNoiseMaterial);
            rightNoise.position.set(10, 5, 30); // 산의 위치를 물 아래로 이동
            scene.add(rightNoise);

            // 육면체 생성 함수
            function createMountainGeometry(width, height, depth) {
                const mountainGeometry = new THREE.BoxGeometry(width, height, depth);
                return mountainGeometry;
            }

            // 왼쪽 육면체 생성
            const leftMountainGeometry = createMountainGeometry(20, 10, 30);
            const leftMountainMaterial = new THREE.MeshBasicMaterial({ color: 0x996633 });
            const leftMountain = new THREE.Mesh(leftMountainGeometry, leftMountainMaterial);
            leftMountain.position.set(20, 5, 0);
            scene.add(leftMountain);

            // 오른쪽 육면체 생성
            const rightMountainGeometry = createMountainGeometry(40, 10, 30);
            const rightMountainMaterial = new THREE.MeshBasicMaterial({ color: 0x996633 });
            const rightMountain = new THREE.Mesh(rightMountainGeometry, rightMountainMaterial);
            rightMountain.position.set(10, 5, 30);
            scene.add(rightMountain);
            
            // 물이 흐르는 효과
            function animate() {
                requestAnimationFrame(animate);

                const time = performance.now() * 0.001;
                const positions = waterGeometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // X와 Y 좌표에 따라 높이 변화를 줌으로써 물결 효과 생성
                    const x = positions[i];
                    const y = positions[i + 1];
                    positions[i + 2] = Math.sin(x * 2 + time) * Math.cos(y * 2 + time) * 0.5;
                }

                waterGeometry.attributes.position.needsUpdate = true;

                // 물과 사이드 벽의 텍스처 오프셋을 애니메이션으로 조정
                const offsetSpeed = 0.001; // 텍스처 이동 속도
                waterTexture.offset.y -= offsetSpeed;
                // sideMaterial.map.offset.y -= offsetSpeed; // 사이드 벽 텍스처도 함께 이동

                renderer.render(scene, camera);
            }
            
            animate();

            document.getElementById('heightInput').addEventListener('change', function(e) {
                const height = parseFloat(e.target.value);
                // Update the side and water position based on the input value
                side.position.y = height / 2; // Adjust based on the center of the geometry
                water.position.y = height; // Set water position to the input value
                side.scale.y = height; // Scale side to match the input height
                document.getElementById('waterVolume').textContent = height * 10000
            });
            
    </script>
    </body>
</html>
